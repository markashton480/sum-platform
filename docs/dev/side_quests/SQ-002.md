# SQ-002: Showroom Kitchen Sink StreamField Gotcha

### What blew up (in plain English)

In `_build_kitchen_sink_stream()` you end up calling:

```py
stream_block.to_python(combined_data)
```

…but `combined_data` is **not raw stream data** anymore. It’s a list of **StreamChild objects** (you can see that in the error: `<block hero_image: StructValue(...)>`, `<block trust_strip_logos: StructValue(...)>`, etc.).

`StreamBlock.to_python()` expects either:

- a list of tuples: `[("hero_image", {...}), ("faq", {...})]`, or
- a list of dicts: `[{"type": "hero_image", "value": {...}}, ...]`

It _can’t_ unpack `StreamChild` items, hence:

> `TypeError: cannot unpack non-iterable StreamChild object`

So the issue is: **you’re “to_python”-ing twice** (or combining already-converted StreamValues/children and trying to convert them again).

---

## The “clean” fix (better long-term)

Refactor `_build_kitchen_sink_stream()` so it only ever builds **raw stream data**, and only converts once (or not at all):

```py
combined_data: list[dict[str, object]] = []

combined_data.append({
    "type": "hero_image",
    "value": {
        "headline": "<p>…</p>",
        "subheadline": "…",
        # etc...
    },
})

combined_data.append({
    "type": "faq",
    "value": {
        "eyebrow": "FAQ",
        "heading": "<p>…</p>",
        "items": [
            {"question": "…", "answer": "<p>…</p>"},
        ],
    },
})

return combined_data
```

Then:

```py
kitchen_sink.body = combined_data
```

No `stream_block.to_python()` needed. This approach is more resilient when you inevitably tweak block definitions over time.

---

## Why you hit it specifically in “Kitchen Sink”

Because kitchen-sink code often does this pattern:

- build section streams individually (each becomes a StreamValue)
- `extend()` them into one combined list
- try to convert again

It’s a super common “double conversion” mistake.

---
