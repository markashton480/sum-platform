## NAV-006 — Navigation Cache Invalidation Layer (signals + helpers + tests)

**Type:** Feature
**Priority:** P0
**Status:** Ready
**Depends on:** NAV-003 (settings models), NAV-005 (tag caching), Branding `SiteSettings`

### Problem

NAV-005 correctly caches rendered nav contexts, but without invalidation the UI can show stale menus/CTAs after editors save settings or publish pages. Spec requires reliable invalidation keyed per-site.

### Goal

Implement the cache invalidation layer described in the spec:

- Standardised cache key helpers
- Signal handlers that delete the right keys on:

  - HeaderNavigation save
  - FooterNavigation save
  - Branding SiteSettings save
  - Page publish/unpublish/delete (site-scoped)

---

## Scope

### In scope

1. `cache.py` helpers: key generation + delete-many.
2. Signal handlers for settings saves + page lifecycle.
3. Ensure signals are registered via AppConfig.
4. Unit tests for key format + invalidation behaviour + site isolation.

### Out of scope

- Cache warming / precompute
- Any template/HTML changes (NAV-007)
- “Referenced page only” precision invalidation (we’ll invalidate per-site on publish/unpublish; acceptable for MVP performance)

---

## Implementation Tasks

### A) Add cache helper module

**Create file:** `core/sum_core/navigation/cache.py`

Implement:

- `get_nav_cache_keys(site_id: int) -> list[str]` returning exactly:

  - `nav:header:{site_id}`
  - `nav:footer:{site_id}`
  - `nav:sticky:{site_id}`

- `invalidate_nav_cache(site_id: int, *, types: set[str] | None = None) -> None`

  - If `types` is None: delete all keys
  - If `types` provided: delete only matching keys (e.g. `{ "header", "sticky" }`)
  - Use `cache.delete_many(...)` for efficiency.

> Keep this module dependency-light (avoid importing templates/templatetags) to prevent circular imports.

---

### B) Signal handlers (invalidations)

**In:** `core/sum_core/navigation/cache.py` (or `signals.py` if you prefer; spec shows `cache.py`)

Register invalidations:

- `post_save` HeaderNavigation → invalidate `header` + `sticky` keys for that instance site

- `post_save` FooterNavigation → invalidate `footer` key for that instance site

- `post_save` Branding `SiteSettings` → invalidate all nav keys for that instance site (because phone/tagline/socials may affect output)

- `page_published` + `page_unpublished` (Wagtail signals)

  - For each site the page belongs to, invalidate **header + footer** (and sticky if you want to be safe)
  - Use a robust “sites for page” calculation suitable for your Wagtail version (don’t assume a `page.get_sites()` method exists unless it does in this codebase).

- `post_delete` for Page

  - Invalidate for the site(s) the page belonged to (best-effort; if sites can’t be resolved at delete-time, invalidate all sites as a safe fallback).

---

### C) Ensure signals are loaded

**Modify:** `core/sum_core/navigation/apps.py`

In `ready()`:

- Import the module that registers receivers (`sum_core.navigation.cache`) so signals are wired in production.

---

### D) Align template tags to shared key helpers (consistency pass)

**Modify (recommended):** `core/sum_core/navigation/templatetags/navigation_tags.py`

- Replace hardcoded key strings with `get_nav_cache_keys(...)` (or a `get_nav_cache_key(site_id, "header")` helper if you add one).
- Must keep key format exactly `nav:{type}:{site_id}`.

This is mainly to prevent future drift.

---

## Tests

**Create file:** `tests/navigation/test_cache.py`

Minimum cases (mirrors spec list):

- `test_cache_key_format` — key format is `nav:{type}:{site_id}`
- `test_cache_stores_on_miss` — (lightweight) ensure tags set cache on miss (can patch cache backend)
- `test_cache_returns_on_hit` — ensure tags read from cache on second call (patch builder)
- `test_header_save_invalidates` — saving HeaderNavigation deletes header+sticky keys
- `test_footer_save_invalidates` — saving FooterNavigation deletes footer key
- `test_page_publish_invalidates` — publishing a page invalidates nav keys for relevant site(s)
- `test_site_isolation` — invalidating site A does not delete site B keys

> Use the same session-scoped DB precautions used in NAV-005 tests (unique slugs, or cleanup fixtures)

---

## Acceptance Criteria

1. Cache key helpers generate the exact keys defined in the spec.
2. Saving HeaderNavigation invalidates header+sticky cache for that site.
3. Saving FooterNavigation invalidates footer cache for that site.
4. Saving Branding SiteSettings invalidates all nav keys for that site.
5. Publishing/unpublishing/deleting a page invalidates nav cache for the affected site(s).
6. Tests pass and confirm site isolation.

---

## Manual QA

1. Load any page twice (to prime cache), then:

   - Update **Header Navigation** menu item label → save → confirm header updates immediately on next page load.
   - Update **Footer Navigation** section link → save → confirm footer updates immediately.

2. Update Branding **SiteSettings** phone/tagline/social → confirm header/footer reflect changes (override/fallback rules still apply).
3. Publish/unpublish a page that is linked in nav → confirm nav highlights/links update without waiting for TTL.
