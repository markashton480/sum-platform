
# Context

Following the implementation of task `M5-003.md` we have the following red flags:

### 1) **`sum check` may not reliably import `sum_core` in real-world usage**

In `run_check`, you add the *client project root* to `sys.path` so settings can import, then you remove it again quickly. But `sum_core` import depends on it being installed in the environment (which is correct), and the test only passes because the test suite manually injects `core/` onto `sys.path` via `_add_repo_core_to_syspath()`.

That means: **in an actual freshly-created client project where the user hasn’t installed deps yet, `sum check` will fail on sum_core import**, which is *okay*, but your acceptance criteria for M5-003 was “init creates project and check passes” and you’re achieving that only inside tests by cheating the environment. The CLI itself prints “install requirements then run sum check”, implying check should be run after install — but your *ticket acceptance* previously implied `sum init foo` then `sum check` passes (after following the instructions). Right now, that boundary is fuzzy.

**Fix**: make the CLI contract explicit in code + docs + tests:

* Either (A) `sum check` is allowed to fail until deps installed (recommended, realistic), and update the integration test to `pip install -r requirements.txt` in a temp venv (heavy), or
* (B) `sum check` should support a *monorepo dev mode* that can locate `sum_core` when run from repo root (explicit behavior, not “test hacks”), e.g. if a `core/` directory exists adjacent to `boilerplate/` then temporarily add it.

Given your goals, I’d choose **B for monorepo dev ergonomics**, and still keep “outside repo requires installed deps”.

### 2) **Packaging/metadata mismatch risk**

They created a separate `cli/pyproject.toml` that defines `name = "sum-cli"` and bundles `sum_cli/boilerplate/**` as package data. That’s fine, but it introduces a “two package managers” shape inside the monorepo: core uses one pattern, CLI uses another. This isn’t wrong, but it’s a **release/process risk** unless we explicitly decide that the CLI is its own installable package (like core) and document the release workflow.

Also, the report explicitly notes “release automation should ensure packaged boilerplate stays in sync.” 
That’s not optional long-term — without a guardrail, the CLI can quietly scaffold stale boilerplate.


### 3) **`sum check`’s health wiring validation is string-based**

It checks for `"sum_core.ops.urls"` substring in the URLConf file.
This is acceptable for v1 (cheap and dependency-free), but it’s slightly brittle:

* someone could include it via a different import path or alias
* or include ops URLs indirectly

This task is a "corrective mission" to resolve these issues. 
When complete, please complete a comprehensive work log and file it in `docs/dev/CM/CM-008_followup.md`. 

---

## **[CM-008]: Make `sum check` contract + environment behavior explicit, and prevent boilerplate drift**

**Objective**: Remove ambiguity around when `sum check` should pass, and add a guardrail so the CLI’s bundled boilerplate cannot silently diverge from canonical `/boilerplate/`.

### Context

* Current tests pass by adding `core/` to `sys.path`, which doesn’t reflect how end users will run `sum check`.
* CLI bundles boilerplate for non-monorepo use, but there’s no automated sync/verification. 

### Technical Requirements

#### 1) Define and enforce `sum check` execution modes

Implement explicit behavior:

* **Mode 1: Monorepo dev mode**

  * If `sum check` is executed inside a repo that contains `core/` at the expected location, allow `sum_core` to be imported without requiring installation by temporarily adding `<repo_root>/core` to `sys.path` for the duration of the check.
  * This should be **explicitly logged** in output: e.g. `[OK] sum_core import (monorepo mode)`.

* **Mode 2: Standalone client mode**

  * If `core/` isn’t present, require `sum_core` to be installed; if not importable, fail with a clear instruction: “Install requirements first”.

**Important**: do *not* keep “test-only sys.path hacks”. The CLI itself should own its behavior.

#### 2) Update docs to match contract

* `docs/dev/cli.md` must clearly state:

  * monorepo dev mode behavior
  * standalone behavior expectations
  * what `sum check` validates and what it doesn’t

#### 3) Update tests so they match reality

* Replace `_add_repo_core_to_syspath()` in tests with the **actual monorepo mode behavior** of the CLI (i.e., let CLI find core itself when run from repo root context).
* Add one negative test confirming standalone mode fails on missing `sum_core` with a friendly message.

#### 4) Add boilerplate drift guard

Add one of:

* A `make` target + CI check that:

  * regenerates `cli/sum_cli/boilerplate/` from `/boilerplate/`
  * fails if git diff exists after regeneration
    **or**
* A test that compares a small set of sentinel files’ contents/hashes between canonical and bundled boilerplate.

Keep it **cheap** and **deterministic**.

### Files to modify (likely)

* `cli/sum_cli/commands/check.py`
* `cli/tests/test_cli_init_and_check.py`
* `docs/dev/cli.md`
* `Makefile` and/or `cli/scripts/sync_boilerplate.py` (if you choose the make target approach)
* Potentially add `cli/sum_cli/boilerplate/.SYNCED_FROM_CANONICAL` marker or similar

### Acceptance Criteria

* `sum check` behavior is deterministic and documented across monorepo vs standalone.
* Tests no longer modify `sys.path` to simulate core availability.
* Bundled boilerplate sync is guarded (CI would fail if it drifts).
* `make lint` + `make test` pass.
