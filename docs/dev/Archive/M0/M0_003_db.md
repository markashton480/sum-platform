## **Task ID**: M0-003 (DB)

**Title**: Introduce Dockerised Postgres & Env-Based DB Config for Test Project

**Goal**
Run the Wagtail test project against Postgres (via Docker) with a clean, env-based configuration, while keeping SQLite as a fallback. No Docker for the app, **only** for Postgres.

---

### Workstream

* **Workstream**: 1 – Platform Infrastructure
* **Milestone**: 0/1 bridge – Foundation hardening before deeper DB work

This is a small infrastructure refinement that strengthens our base before we start doing anything interesting with models, queries, or migrations.

---

### Inputs Required

**Existing code**

* `core/sum_core/test_project/test_project/settings.py`

  * Currently defines `DATABASES` with SQLite only.
* Current `Makefile`

  * Has dev commands (`lint`, `test`, `run`) but no DB helpers yet.
* Docker is already installed on your machine (assumed – you’re on WSL and you’ve mentioned Docker previously).

**Constraints / Intent**

* We **do not** want full Docker dev (no web container).
* We **do** want:

  * Postgres as the primary DB for real work.
  * SQLite still available for “quick run with nothing installed” scenarios.
* We want this test project to approximate eventual prod as far as DB engine is concerned.

---

### Files / Modules to Touch

* **New**: `docker-compose.yml` (repo root)
* **New**: `.env.example` (repo root)
* **Modify**: `core/sum_core/test_project/test_project/settings.py`
* **Modify**: `Makefile`
* **(Optional)**: `README.md` (brief DB setup note)

---

### Implementation Steps

#### 1. Add Dockerised Postgres service

Create `docker-compose.yml` at the repo root:

```yaml
version: "3.9"

services:
  db:
    image: postgres:17
    environment:
      POSTGRES_DB: sum_db
      POSTGRES_USER: sum_user
      POSTGRES_PASSWORD: sum_password
    volumes:
      - sum_db_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  sum_db_data:
```

Notes:

* `sum_db_data` keeps DB data between restarts.
* We expose `5432` so Django can connect from the host.

#### 2. Add env file template

Create `.env.example` at the repo root:

```env
# Database settings for local Postgres (Docker)
DJANGO_DB_NAME=sum_db
DJANGO_DB_USER=sum_user
DJANGO_DB_PASSWORD=sum_password
DJANGO_DB_HOST=localhost
DJANGO_DB_PORT=5432
```

Usage for dev:

```bash
cp .env.example .env
# then export or use direnv / python-dotenv; or just set these in your shell
```

(If your current setup already loads `.env` into the environment, great. If not, you can export them manually while developing.)

#### 3. Make `settings.py` DB config env-driven

In `core/sum_core/test_project/test_project/settings.py`:

1. At the top (near other imports):

```python
import os
```

2. Replace the existing `DATABASES = {...}` block with an env-aware version:

```python
DB_NAME = os.getenv("DJANGO_DB_NAME")
DB_USER = os.getenv("DJANGO_DB_USER")
DB_PASSWORD = os.getenv("DJANGO_DB_PASSWORD")
DB_HOST = os.getenv("DJANGO_DB_HOST")
DB_PORT = os.getenv("DJANGO_DB_PORT", "5432")

if DB_HOST and DB_NAME:
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.postgresql",
            "NAME": DB_NAME,
            "USER": DB_USER,
            "PASSWORD": DB_PASSWORD,
            "HOST": DB_HOST,
            "PORT": DB_PORT,
        }
    }
else:
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }
```

Behaviour:

* If `DJANGO_DB_HOST` **and** `DJANGO_DB_NAME` exist → use Postgres.
* Otherwise → fall back to SQLite exactly as today.

This keeps:

* Easy “just run it” behaviour (no env → SQLite).
* Proper Postgres when you explicitly opt in.

#### 4. Make Makefile helpers for DB

In the root `Makefile`, add:

```make
db-up:
	docker-compose up -d db

db-down:
	docker-compose down
```

Optional nice-to-have:

```make
db-logs:
	docker-compose logs -f db
```

Now you have:

```bash
make db-up    # start Postgres
make db-down  # stop Postgres
```

#### 5. Migrate to Postgres (once)

With your main venv active, and after creating `.env` from `.env.example`:

```bash
make db-up
export DJANGO_DB_NAME=sum_db
export DJANGO_DB_USER=sum_user
export DJANGO_DB_PASSWORD=sum_password
export DJANGO_DB_HOST=localhost
export DJANGO_DB_PORT=5432

python core/sum_core/test_project/manage.py migrate
python core/sum_core/test_project/manage.py createsuperuser  # if you want a fresh one
python core/sum_core/test_project/manage.py runserver
```

Sanity check:

* `/admin/` loads.
* SiteSettings and all existing admin functionality works.
* Your existing tests (`make test`) still pass when env vars are set (so tests hit Postgres too).

---

### Acceptance Criteria

* [ ] `docker-compose.yml` exists at repo root with a `db` service using `postgres:17` and a named volume.
* [ ] `.env.example` exists with `DJANGO_DB_*` variables for DB name, user, password, host, and port.
* [ ] `core/sum_core/test_project/test_project/settings.py`:

  * Reads DB settings from env vars.
  * Uses Postgres when `DJANGO_DB_HOST` and `DJANGO_DB_NAME` are set.
  * Falls back to SQLite when they are not.
* [ ] `Makefile` includes `db-up` and `db-down` targets for managing the Postgres container.
* [ ] From a clean environment:

  * Without env vars → project still runs using SQLite.
  * With env vars + `make db-up` → project runs against Postgres; `migrate` completes successfully.
* [ ] `make lint` and `make test` still pass with Postgres configuration active.

---

### Testing Requirements

**Automated**

* Run `make test` with Postgres env vars set:

  * Confirm tests interact happily with Postgres.
* Optionally run `make test` with no env vars to implicitly test the SQLite path (not critical, but useful for detecting path regressions).

**Manual**

1. **SQLite path sanity:**

   * Unset `DJANGO_DB_*` vars.
   * `python core/sum_core/test_project/manage.py runserver`.
   * Confirm `/admin/` works (existing behaviour).

2. **Postgres path sanity:**

   * `make db-up`.
   * Export `DJANGO_DB_*` env vars.
   * `python core/sum_core/test_project/manage.py migrate`.
   * `python core/sum_core/test_project/manage.py runserver`.
   * Hit `/admin/` → confirm everything behaves as expected.

---

### Estimated Effort

* **Effort**: S (1–2 focused hours)
* **Risk**: Low–Medium

  * Low because this is config-only, no model changes.
  * Medium because DB-switch bugs can be subtle if not exercised; mitigated by running migrations + tests against Postgres immediately.


