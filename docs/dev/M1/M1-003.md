## **[M1-003] Branding CSS & Font Template Tags**

### Context (from PRD & Implementation Plan)
This is a Wagtail/Django project. 

Milestone 1 is about the **design system & base templates**. Implementation Plan lists:

* **DESIGN-001** – CSS Token System (done)
* **DESIGN-003** – SiteSettings Model (done)
* **DESIGN-004** – Branding Template Tags (this task)
* Plus base templates & theme presets later.

From the PRD:

**US-BR02: Dynamic CSS Generation**

> As a developer, I want CSS variables generated from branding settings so that styles update automatically.

Acceptance criteria (P0):

* AC1 – Template tag `{% branding_css %}` outputs CSS custom properties in `<head>`
* AC2 – CSS variables: `--color-primary`, `--color-secondary`, `--color-accent`, `--color-background`, `--color-text`, etc.
* AC4 – Google Fonts `<link>` tags generated dynamically based on selected fonts
* AC5 – Font variables: `--font-heading`, `--font-body`
* AC6 – Changes reflect immediately in development (no caching issues)
* AC7 – Production: CSS output cached, invalidated on settings change

Appendix C defines the **canonical tokens** and explicitly shows they are populated from `SiteSettings` fields (e.g. `--color-primary: /* from SiteSettings.color_primary */;`, `--font-heading: /* from SiteSettings.font_heading */`). Our current `SiteSettings` uses names like `primary_color`, `heading_font`, etc., but the semantics are the same.

We’ve already:

* Implemented `main.css` with `:root` tokens and utilities.
* Implemented `SiteSettings` with colours, fonts, logos, business info, and social links.
* Implemented `get_site_settings` with per-request caching.

This task wires those together into **runtime branding**.

---

### Technical Requirements

**Goal:**

Provide two template tags:

* `{% branding_css %}` – emits a `<style>` element defining CSS variables (`--color-*`, `--font-*`) for the current Site based on `SiteSettings`.
* `{% branding_fonts %}` – emits `<link>` tag(s) for Google Fonts based on `heading_font` and `body_font`.

They must:

* Use `SiteSettings` as the source of truth.
* Override the defaults in `main.css` (by being included *after* `main.css` in the `<head>`).
* Respect dev vs production caching semantics:

  * **Dev (DEBUG=True):** no cross-request caching; changes show immediately.
  * **Prod (DEBUG=False):** output cached per Site and invalidated when settings change.

#### 1. Locations & Modules

Existing structure (from previous task):

* Branding app: `core/sum_core/branding/`
* Template tags:

  * `core/sum_core/branding/templatetags/branding_tags.py` (core implementation)
  * `sum_core/templatetags/branding_tags.py` (re-export so `{% load branding_tags %}` works)

For this task:

* **Extend** the existing `branding_tags.py` in the branding app with two new tags.
* Ensure the top-level `sum_core.templatetags.branding_tags` continues to import/re-export these tags; if it doesn’t yet, add it.

#### 2. `{% branding_css %}` behaviour

Signature:

```python
@register.simple_tag(takes_context=True)
def branding_css(context: dict[str, Any]) -> str:
    ...
```

Responsibilities:

1. **Resolve SiteSettings**

   * Reuse existing `get_site_settings(context)` helper (import it if needed) OR repeat the logic (Site.find_for_request + SiteSettings.for_site) if cleaner.
   * Work with both:

     * A real request (normal templates),
     * Test contexts using `RequestFactory` (unit tests).

2. **Build CSS variables**

   Read from our current `SiteSettings` fields (based on tests):

   * `primary_color` → `--color-primary`
   * `secondary_color` → `--color-secondary`
   * `accent_color` → `--color-accent`
   * `background_color` → `--color-background`
   * `surface_color` → `--color-surface` (fallback to design reference default if blank)
   * `surface_elevated_color` → `--color-surface-elevated` (fallback to default)
   * `text_color` → `--color-text`
   * `text_light_color` → `--color-text-light`
   * (Optionally) we can leave `--color-text-inverse`, `--color-success`, `--color-warning`, `--color-error`, `--color-info`, `--color-border`, `--color-border-dark` as **fixed tokens** in `main.css`, not dynamic here.

   For fonts:

   * `heading_font` → `--font-heading`
   * `body_font` → `--font-body`

   Behaviour:

   * If a field is blank, **don’t output an assignment** for that token and let `main.css` default stand.
   * For fonts, when non-blank, wrap family names in quotes and include a fallback stack. For example:

     ```css
     --font-heading: "Playfair Display", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
     --font-body: "Open Sans", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
     ```

3. **Output format**

   The tag should return a complete `<style>` tag, e.g.:

   ```html
   <style id="branding-css">
   :root {
       --color-primary: #123456;
       --color-secondary: #abcdef;
       ...
   }
   </style>
   ```

   * Use `django.utils.html.format_html` or `mark_safe` responsibly (we control data via admin; risk is low but we can still escape where sensible).
   * Ensure newline/indentation is readable but not critical.

4. **Caching**

   * Use Django’s cache (`django.core.cache`) for cross-request caching.

   * Key per site, e.g.: `branding_css:{site_id}`.

   * Behaviour:

     * **When `settings.DEBUG` is True**:

       * Skip cache entirely. Always regenerate CSS from current `SiteSettings`.
     * **When `settings.DEBUG` is False**:

       * `cached = cache.get(cache_key)`
       * If present, return `cached`.
       * Otherwise build the CSS, `cache.set(cache_key, css, timeout=... )`, return it.

   * **Invalidation**:

     * On `SiteSettings` save/delete, invalidate the cache for that site.
     * Implement either:

       * A `save()` override on `SiteSettings` that deletes `branding_css:{site_id}` and `branding_fonts:{site_id}` after `super().save(...)`, **or**
       * `post_save` / `post_delete` signals hooked in `branding/models.py` or a `signals.py` imported from `apps.py`.

#### 3. `{% branding_fonts %}` behaviour

Signature:

```python
@register.simple_tag(takes_context=True)
def branding_fonts(context: dict[str, Any]) -> str:
    ...
```

Responsibilities:

1. **Resolve SiteSettings** in the same way as `branding_css`.

2. **Determine fonts**

   * Start from `heading_font` and `body_font` fields.
   * Normalise for URLs:

     * Strip leading/trailing whitespace.
     * Replace spaces with `+` for Google Fonts family names.
   * Deduplicate: if heading and body fonts are the same, only include one family.

3. **Generate `<link>` tag(s)**

   * If both fonts are blank → return empty string.

   * Use the Google Fonts CSS2 endpoint:

     ```html
     <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;700&family=Open+Sans:wght@400;500;700&display=swap">
     ```

   * It’s fine to:

     * Hardcode `wght@400;500;700` as the initial weight set for both fonts.
     * Combine families into a single `href`.

   * Optional (nice-to-have, not mandatory right now): preconnect links:

     ```html
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
     ```

4. **Caching**

   * Same strategy as `branding_css`:

     * No caching when `DEBUG=True`.
     * Cached per site when `DEBUG=False` with a key like `branding_fonts:{site_id}`.
     * Invalidation on `SiteSettings` save/delete.

---

### Design Specifications & Alignment

* **Token alignment:**
  `branding_css` must set the exact tokens that `main.css` and Appendix C expect:

  * Colour tokens: `--color-primary`, `--color-secondary`, `--color-accent`, `--color-background`, `--color-surface`, `--color-surface-elevated`, `--color-text`, `--color-text-light`.
  * Font tokens: `--font-heading`, `--font-body`.

* **Override behaviour:**

  * `main.css` provides sensible defaults for all tokens.
  * `branding_css` simply **overrides** a subset in a later `<style>` block.
  * Base templates (a later task) will include `main.css` first, then `{% branding_css %}` and `{% branding_fonts %}` in `<head>`.

* **Future HSL model:**
  This ticket does *not* implement the full HSL relationship engine from `design_system.md`. It should, however, keep the structure flexible enough that we can later derive secondary tokens (like `--primary-deep`, `--surface-tint`) from one or two core colours without changing the template tag API.

---

### Implementation Guidelines

**Files to create/modify**

1. `core/sum_core/branding/templatetags/branding_tags.py`

   * Add/extend header docstring with module purpose.
   * Ensure it defines:

     * `get_site_settings`
     * `branding_css`
     * `branding_fonts`

2. `sum_core/templatetags/branding_tags.py`

   * Re-export the tags from the branding app so `{% load branding_tags %}` always works from client templates.

3. `core/sum_core/branding/models.py`

   * If you opt for `save()`-based cache invalidation or signals, update this file accordingly.
   * Ensure header comment is present and model uses type hints where appropriate (methods, helpers).

**Header comments**

Every modified/created Python file must maintain the standard header:

```python
"""
Name: [Module Name]
Path: [File path]
Purpose: [Brief description]
Family: [What depends on this]
Dependencies: [What this depends on]
"""
```

---

### Acceptance Criteria

* [ ] `{% branding_css %}`:

  * Returns a `<style>` block with `:root { ... }` containing CSS variable assignments for:

    * `--color-primary`, `--color-secondary`, `--color-accent`, `--color-background`, `--color-surface`, `--color-surface-elevated`, `--color-text`, `--color-text-light` when corresponding `SiteSettings` fields are populated.
    * `--font-heading`, `--font-body` when `heading_font` / `body_font` are populated, including fallback stacks.
  * Uses existing `SiteSettings` values; no hardcoded brand colours in the tag.
  * In dev (`DEBUG=True`), changes to settings are reflected on the next page load with no cache staleness.

* [ ] `{% branding_fonts %}`:

  * Outputs valid `<link rel="stylesheet" href="https://fonts.googleapis.com/...">` markup when fonts are set.
  * Works correctly when:

    * Only heading font is set.
    * Only body font is set.
    * Both are set and distinct.
    * Both are blank (outputs nothing).

* [ ] Caching:

  * In dev (`DEBUG=True`), both tags bypass cache and always reflect current settings.
  * In production (`DEBUG=False`), both tags cache per site and invalidate when `SiteSettings` is saved or deleted.

* [ ] Integration:

  * `{% load branding_tags %}` works from templates (via `sum_core.templatetags`).
  * `make lint` and `make test` continue to pass.

---

### Dependencies & Prerequisites

* Milestone 0 complete (repo/tooling/test project).
* **M1-001** CSS token system implemented (`main.css`).
* **M1-002** `SiteSettings` model and `{% get_site_settings %}` tag implemented and tested.
* Wagtail admin working (which you’ve confirmed).

---

### Testing Requirements

**Unit tests (recommended locations)**

Under `tests/branding/`:

1. `test_branding_css.py`

   * `test_branding_css_outputs_site_colors`:

     * Set `SiteSettings` colours and fonts.

     * Render a template:

       ```django
       {% load branding_tags %}
       {% branding_css %}
       ```

     * Assert that the output contains `--color-primary: #123456;`, `--color-background: #ffffff;`, etc., and `--font-heading: "Some Font"` when set.
   * `test_branding_css_respects_defaults_when_blank`:

     * Leave one or more fields blank.
     * Assert those tokens are not emitted, so defaults from `main.css` remain in effect.

2. `test_branding_fonts.py`

   * `test_branding_fonts_outputs_google_fonts_link`:

     * Set `heading_font = "Playfair Display"`, `body_font = "Open Sans"`.
     * Render `{% branding_fonts %}` and assert the `href` includes both families (`Playfair+Display` and `Open+Sans`).
   * `test_branding_fonts_deduplicates_same_font`:

     * Set both fonts to same value; assert only one `family=` appears.
   * `test_branding_fonts_empty_when_no_fonts`:

     * Both blank → output is empty string.

> Mark these modules with `pytestmark = pytest.mark.django_db`.

**Optional caching tests**

* Use `override_settings(DEBUG=False)` and Django’s `CaptureQueriesContext` or cache inspection to verify:

  * First call triggers DB access for SiteSettings.
  * Second call within a new request reuses cached output and avoids extra queries.

---

### Estimated Complexity

* **Time:** M (4–5 hours)
* **Risk:** Medium

  * Main risks:

    * Incorrect mapping between `SiteSettings` fields and CSS variables.
    * Hardcoded colours/fonts creeping into tags instead of using tokens.
    * Over-aggressive caching causing stale branding in dev.
  * Mitigations:

    * Strict alignment with Appendix C token names.
    * Explicit dev vs prod behaviour.
    * Tests asserting both CSS content and basic caching semantics.

